<!DOCTYPE html>
<html lang="en">
  
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>computed vs watch</title>
</head>

<body>
  <div id="example1">
    <h4>computed 사용</h4>
    <h5>computed 속성은 종속 대상을 따라 저장(캐싱)된다!<br>
      종속된 대상이 변경될 때만 함수를 실행합니다. <br>
      즉 message가 변경되지 않는 한, computed 속성인 reversedMessage를 여러 번 요청해도<br>
      계산을 다시 하지 않고 계산되어 있던 결과를 즉시 반환합니다. </h5>

    <p>원본 메시지: "{{ message }}"</p>
    <p>역순으로 표시한 메시지: "{{ reversedMessage }}"</p>

    <input type="text" id="messageInput">
    <button v-on:click="changeText">추가</button>
  </div>

  <div id="example2">
    <h4>computed vs watch <br> watch</h4>
    <h5>watch 속성은 감시할 데이터를 지정하고<br>
    그 데이터가 바뀌면 이런 함수를 실행하라는 방식 </h5>

    {{ fullName }}

    <input type="text" id="firstName1" placeholder="first name" style="display: block;">
    <input type="text" id="lastName1" placeholder="last name">
    <button v-on:click="changeName" style="display: block;">입력</button>
  </div>

  <div id="example3">
    <h4>computed</h4>
    <h5>watch 코드는 명령형이고, 코드 반복이 있다.<br>
    computed 속석을 사용하는 방식과 비교해보쟈 </h5> 

    {{ fullName }}

    <input type="text" id="firstName2" placeholder="first name" style="display: block;">
    <input type="text" id="lastName2" placeholder="last name">
    <button v-on:click="changeName" style="display: block;">입력</button>
  </div>

  <div id="example4">
    <h4>watch</h4>
    <p>
      질문해보세요 :
      <input v-model="question">
      <!-- v-model의 questino은 watch의 question이다. -->
    </p>
    <p>{{ answer }}</p>
  </div>
  
  <script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
  <script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="js/main.js"></script>
</body>
</html>